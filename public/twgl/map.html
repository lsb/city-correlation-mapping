<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>web sitelol</title>
    <style>
      canvas {
          display: inline-block;
          width: 256px;//100vw;
          height: 256px;//100vh;
          margin: auto;
      }
      #b {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 2;
      }
    </style>
    <link rel="stylesheet" href="leaflet.css"/>
    <script src="leaflet.js"></script>
    <style>#map { height: 90vh; width: 90vw; }</style>
  </head>
  <body style="background-color:white">
    <canvas id="c" style="visibility:hidden;position:fixed;x:0;y:0"></canvas><br>
    <div id="b">hi lol</div>
    <div>
      here is some text lol
      <canvas id="f1"></canvas>
      <canvas id="f2"></canvas>
      <canvas id="f3"></canvas>
      <canvas id="f4"></canvas><hr>
      <canvas id="f5"></canvas><canvas id="f6"></canvas>
      <hr>
      <canvas id="f22"></canvas>
      <hr><hr>
      <div><div><canvas id="w0"></canvas><canvas id="w1"></canvas></div><div><canvas id="w2"></canvas><canvas id="w3"></canvas></div></div>
    </div>
    <hr><hr><hr>
    <div id="map"></div>
  </body>
  <script id="p30b1vtxboxes" type="notjs">#version 300 es
    in ivec2 p30b1;
    out vec2 frag_pos;
    uniform uint x;
    uniform uint y;
    uniform uint z;
    uniform float rad;
    void main() {
      frag_pos = vec2(sign(p30b1));
      ivec2 pGlobal = ((abs(p30b1) >> (22 - int(z))) - (ivec2(x,y) << 8));
      int irad = int(rad+1.0);
      pGlobal.x += (1 << (int(z)+8)) * ((pGlobal.x > (256 + irad)) ? -1 : ((-irad > pGlobal.x) ? 1 : 0));

      gl_Position = vec4((vec2(pGlobal) + frag_pos * rad)/128.0 * vec2(1.0,-1.0) - vec2(1.0,-1.0), 0.0, 1.0);
    }
  </script>
  <script id="fs" type="notjs">#version 300 es
precision highp float;
uniform float r;
uniform float g;
uniform float b;
uniform float rad;
in vec2 frag_pos;
out vec4 outColor;

void main() {
  float color = 1.0 - smoothstep(0.25/rad, 0.0, 1.0 - length(frag_pos));
  if(color == 0.0) {
    discard;
  } else {
    outColor = vec4( r, g, b, color);
  }
}
  </script>
  <script id="partialEdgeTriangle" type="notjs">#version 300 es
    precision highp int;
    precision highp float;
    in ivec4 edge;
    out float edgeA;
    out float edgeAFade;
    uniform uint x;
    uniform uint y;
    uniform uint z;
    uniform float edgeWidth;
    uniform float edgeDecayPx;
    uniform float edgeDisappearPx;
    uniform float partialStart;
    uniform float partialWidth;
    uniform float edgeWorldWidthWrap;
    void main() {
      ivec4 unsortedsrcdst = abs(edge) >> (22 - int(z));
      ivec4 srcdst = (unsortedsrcdst.x < unsortedsrcdst.z) ? unsortedsrcdst.xyzw : unsortedsrcdst.zwxy;

      float tileEdgeStart = partialStart * 256.0;
      float tileEdgeWidth = partialWidth * 256.0;
      float tileEdgeEnd   = tileEdgeStart + tileEdgeWidth;

      vec4 unwrappedEdgeRelUR = vec4(srcdst - (ivec4(x,y,x,y) << 8));
      bool notToBeWrapped = float(srcdst.z - srcdst.x) < (edgeWorldWidthWrap * pow(2.0, float(z)+8.0));
      bool srcCloserThanDst = abs(unwrappedEdgeRelUR.z - tileEdgeStart - tileEdgeWidth / 2.0) > abs(unwrappedEdgeRelUR.x - tileEdgeStart - tileEdgeWidth / 2.0);
      vec4 edgeRelUR = (notToBeWrapped) ? unwrappedEdgeRelUR : (unwrappedEdgeRelUR.zwxy + ((srcCloserThanDst) ? vec4(-pow(2.0, float(z) + 8.0),0,0,0) : vec4(0,0,pow(2.0, float(z) + 8.0),0)));

      float triStart = max(tileEdgeStart, edgeRelUR.x);
      float triEnd = min(tileEdgeEnd, edgeRelUR.z);

      vec2 triBounds = vec2(triStart, triEnd);

      vec2 edgeProgress = smoothstep(0.0, 1.0, smoothstep(edgeRelUR.xx, edgeRelUR.zz, triBounds));
      vec2 latProgress = mix(edgeRelUR.yy, edgeRelUR.ww, edgeProgress);
      vec4 slopeProgress = mix(edgeRelUR.yyyy, edgeRelUR.wwww, smoothstep(0.0, 1.0, smoothstep(edgeRelUR.xxxx, edgeRelUR.zzzz, vec4(triStart - 0.5, triStart + 0.5, triEnd - 0.5, triEnd + 0.5))));
      vec4 edgeWidthBothSides = smoothstep(0.0, 1.0, smoothstep(edgeDecayPx, edgeDisappearPx, abs(edgeRelUR.xzxz - triBounds.xxyy)));
      vec2 edgeWidthProgress = 1.0 - min(edgeWidthBothSides.xz, edgeWidthBothSides.yw);


      bool edgeInRange = edgeRelUR.x <= tileEdgeEnd && tileEdgeStart <= edgeRelUR.z && length(edgeWidthProgress) > 0.0;

      vec3 zcross = vec3(0,0,sign(edge.y)) * edgeWidth;
      gl_Position = !edgeInRange ? vec4(-2.0,-2.0,2.0,1.0) : vec4( ( ((edge.x > 0) ? (vec2(triEnd, latProgress[1])   + vec2(cross(normalize(vec3(1.0,slopeProgress[3]-slopeProgress[2],0.0)),zcross * edgeWidthProgress[1]))) :
                                                                                     (vec2(triStart, latProgress[0]) + vec2(cross(normalize(vec3(1.0,slopeProgress[1]-slopeProgress[0],0.0)),zcross * edgeWidthProgress[0]))))
                                                                     * vec2(1.0 / 128.0, -1.0 / 128.0)) + vec2(-1.0, 1.0), 0.0, 1.0);


      edgeA = (edge.y > 0) ? -1.0 : 1.0;
      edgeAFade = (edge.x > 0) ? edgeWidthProgress[1] : edgeWidthProgress[0];
    }
  </script>
  <script id="smoothThickEdge" type="notjs">#version 300 es
    precision lowp float;
    in float edgeA;
    in float edgeAFade;
    uniform float edgeR;
    uniform float edgeG;
    uniform float edgeB;
    uniform float edgeMaxAlpha;
    out vec4 outcolor;
    void main() {
      outcolor = vec4(edgeR, edgeG, edgeB, edgeMaxAlpha * edgeAFade * (1.0 - smoothstep(0.9,1.0, abs(edgeA))));
    }
  </script>

  <script src="twgl.min.js"></script>
  <script src="places.js"></script>
  <script src="edgeSedgeD.js"></script>
  <script>
    function lng2tile(lon,zoom) {
      return (Math.floor((lon+180)/360*Math.pow(2,zoom)));
    }
    function lat2tile(lat,zoom) {
      return (Math.floor((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom)));
    }
    function clamp(min, max, val) { return val < min ? min : (val > max ? max : val) }
    const maxPlaceId = places.slice(-1)[0][0] + 1;
    const maxZ30 = (1 << 30) - 1;
    used = new Uint8Array(maxPlaceId);
    lat30m = new Uint32Array(maxPlaceId);
    lng30m = new Uint32Array(maxPlaceId);
    titles = [];

    const min_lat_degree = - Math.atan(Math.sinh(Math.PI)) * 180 / Math.PI;
    const max_lat_degree = - min_lat_degree;

    places.forEach(function([id, lat, lng, title]) {
      used[id] = 1;
      lat30m[id] = clamp(1, maxZ30, lat2tile((lat > 0) ? Math.min(max_lat_degree, lat) : Math.max(min_lat_degree, lat), 30));
      lng30m[id] = clamp(1, maxZ30, lng2tile(lng,30));
    });
  </script>
  <script>
    ptc = new Int32Array(lat30m.length * 12); // lng- lat- lng- lat+ lng+ lat+  lng+ lat+ lng+ lat- lng- lat-    lng...
    used.forEach((e,i) => { if(e>0) {
      const lat = lat30m[i];
      const lng = lng30m[i];
      ptc[i*12+0] = ptc[i*12+2] = ptc[i*12+4] = ptc[i*12+6] = ptc[i*12+8] = ptc[i*12+10] = lng;
      ptc[i*12+1] = ptc[i*12+3] = ptc[i*12+5] = ptc[i*12+7] = ptc[i*12+9] = ptc[i*12+11] = lat;
      ptc[i*12+0] *= -1; ptc[i*12+1] *= -1; ptc[i*12+2] *= -1; ptc[i*12+9] *= -1; ptc[i*12+10] *= -1; ptc[i*12+11] *= -1;
    }});
    //edgeS[0] = 268951; edgeD[0] = 2138;
    etc = new Int32Array(edgeS.length * 24); // slng- slat+ dlng dlat sn+ sa+ dn da sn+ sa- dn da / sn- sa+ dn da sn+ sa- dn da sn- sa- dn da // sn- sa+ dn da sn+ sa+ dn da sn+ sa- dn da
    //etc = new Int32Array(5 * 24);
    Array.from(edgeS).slice(0,1000000).forEach((s,i) => {
      const ei = i * 24;
      const d = edgeD[i];
      const sa = lat30m[s];
      const sn = lng30m[s];
      const da = lat30m[d];
      const dn = lng30m[d];
      etc[ei+00] = etc[ei+04] = etc[ei+08] = etc[ei+12] = etc[ei+16] = etc[ei+20] = sn;
      etc[ei+01] = etc[ei+05] = etc[ei+09] = etc[ei+13] = etc[ei+17] = etc[ei+21] = sa;
      etc[ei+02] = etc[ei+06] = etc[ei+10] = etc[ei+14] = etc[ei+18] = etc[ei+22] = dn;
      etc[ei+03] = etc[ei+07] = etc[ei+11] = etc[ei+15] = etc[ei+19] = etc[ei+23] = da;
      etc[ei+00] = etc[ei+12] = etc[ei+20] = -sn;
      etc[ei+09] = etc[ei+17] = etc[ei+21] = -sa;
    });
  </script>
  <script>
    "use strict";
    console.log('hi lol');
    const gl = document.querySelector("#c").getContext("webgl2");
    gl.enable( gl.BLEND );
    gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

    const programInfo = twgl.createProgramInfo(gl, ["p30b1vtxboxes", "fs"]);
    const tessedgeProgramInfo = twgl.createProgramInfo(gl, ["partialEdgeTriangle", "smoothThickEdge"])
    const arrays = {
      p30b1: {numComponents: 2, data: ptc}
    };
    const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

    const edgeArrays = {
      edge: {numComponents: 4, data: etc}
    };
    const edgeBufferInfo = twgl.createBufferInfoFromArrays(gl, edgeArrays);

    function render(xyz, destinationCanvas) {
      const startTime = Date.now();
      twgl.resizeCanvasToDisplaySize(gl.canvas);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      const uniforms = {
        x: 5,
        y: 12,
        z: 5,
        rad: 8,
        r: 0.375,//0.25,
        g: 0.75,//0.5,
        b: 1,//1,
        edgeR: 0.75,
        edgeG: 0.25,
        edgeB: 0.25,
        edgeMaxAlpha: 0.05,
        edgeWidth: 5,
        edgeDecayPx: 512, // maybe make this proportional to window size lol
        edgeDisappearPx: 4096,
        edgeWorldWidthWrap: 0.60,
        ...xyz
      };

      if(!xyz.noShadow) {
      gl.useProgram(programInfo.program);
      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
      twgl.setUniforms(programInfo, uniforms);
      twgl.drawBufferInfo(gl, bufferInfo, gl.TRIANGLES);
      }
      const shadowTime = Date.now();

      if(!xyz.noEdge) {
      gl.useProgram(tessedgeProgramInfo.program);
      twgl.setBuffersAndAttributes(gl, tessedgeProgramInfo, edgeBufferInfo);
      var partialWidth = xyz.partialWidth || (1 / 32);
      var partialStart = xyz.partialStart || 0.00001;
      var stripeCount = xyz.stripeCount || (1 / partialWidth);
      for(; partialStart < 1 && stripeCount > 0; stripeCount--, partialStart += partialWidth) {
        twgl.setUniforms(tessedgeProgramInfo, {...uniforms, ...({ partialStart, partialWidth })});
        twgl.drawBufferInfo(gl, edgeBufferInfo, gl.TRIANGLES);
      }
      }
      const edgeTime = Date.now();

      if(!xyz.noPoint) {
      gl.useProgram(programInfo.program);
      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
      twgl.setUniforms(programInfo, {...uniforms, ...({rad: 1.5, r: 0, g: 0, b: 0})});
      twgl.drawBufferInfo(gl, bufferInfo, gl.TRIANGLES);
      }
      const pointTime = Date.now();
      gl.finish();
      const finishTime = Date.now();
      destinationCanvas.width = gl.canvas.width;
      destinationCanvas.height = gl.canvas.height;
      destinationCanvas.getContext("2d").drawImage(gl.canvas,0,0,gl.canvas.width,gl.canvas.height);
      const copyTime = Date.now();
      //console.log({startTime, shadowTime, edgeTime, pointTime, finishTime, copyTime});
      gl.clear(gl.COLOR_BUFFER_BIT);
    }
    requestAnimationFrame(() => render({x:327, y:791, z:11}, document.getElementById("f2")));
    requestAnimationFrame(() => render({x:603, y:769, z:11}, document.getElementById("f3")));
    requestAnimationFrame(() => render({x:5, y:12, z:5}, document.getElementById("f4")));
    requestAnimationFrame(() => render({x:0, y:0, z:0}, document.getElementById("f1")));
    requestAnimationFrame(() => render({x:255, y:141, z:8}, document.getElementById("f5")));
    requestAnimationFrame(() => render({x:0, y:141, z:8}, document.getElementById("f6")));
    requestAnimationFrame(() => render({x:2095652, y:1394698, z:22}, document.getElementById("f22")));

    requestAnimationFrame(() => render({x:0, y:0, z:1}, document.getElementById("w0")));
    requestAnimationFrame(() => render({x:1, y:0, z:1}, document.getElementById("w1")));
    requestAnimationFrame(() => render({x:0, y:1, z:1}, document.getElementById("w2")));
    requestAnimationFrame(() => render({x:1, y:1, z:1}, document.getElementById("w3")));
    setTimeout(() => {
      var map = L.map('map', {
        center: [37.7619, -122.4369],
        zoom: 13,
        maxZoom: 22,
        minZoom: 1,
        zoomSnap: 1,
      });
      var shadowOverlay = L.GridLayer.extend({
        createTile: function({x,y,z}) {
          var t = L.DomUtil.create('canvas', 'pOver');
          requestAnimationFrame(() => render({x,y,z, noPoint: true, noEdge: true}, t));
          return t;
        }
      });
      var edgeOverlayShardCount = 1;
      var repeatShardCount = 8;
      var edgeOverlays = [...Array(edgeOverlayShardCount)].map((e,i) => L.GridLayer.extend({
        createTile: function({x,y,z}) {
          var t = L.DomUtil.create('canvas', 'pOver');
          setTimeout(() => requestAnimationFrame(() => render({x,y,z, noPoint: true, noShadow: true, partialStart : ((i - 0.5/repeatShardCount) / edgeOverlayShardCount), partialWidth: (1/repeatShardCount)/edgeOverlayShardCount, stripeCount: repeatShardCount+1}, t)), 0);
          return t;
        }
      }));
      var pointOverlay = L.GridLayer.extend({
        createTile: function({x,y,z}) {
          var t = L.DomUtil.create('canvas', 'pOver');
          requestAnimationFrame(() => render({x,y,z, noEdge: true, noShadow: true}, t));
          return t;
        }
      });
      var yellowboxnumbers = L.GridLayer.extend({createTile: function(coords) { var t = document.createElement('canvas'); var size = this.getTileSize(); t.width = size.x ; t.height = size.y; var ctx = t.getContext('2d'); ctx.font = '0.25in monospace'; setTimeout(() => { ctx.beginPath(); ctx.fillStyle=`rgba(255,255,${0 + Math.floor(Math.random() * 255)},255)`; ctx.rect(0,0,size.x,size.y); ctx.fill();ctx.fillStyle=`black`;ctx.fillText(JSON.stringify([coords.x, coords.y, coords.z]),0,20);},0); return t; }});
      //map.addLayer(new yellowboxnumbers());

      var whiteTiles = L.GridLayer.extend({createTile: function() {
          var t = document.createElement('canvas');
          var size = this.getTileSize(); t.width = size.x; t.height = size.y;
          var ctx = t.getContext('2d');
          ctx.fillStyle='white'; ctx.rect(0,0,size.x,size.y); ctx.fill();
          return t;
      }});
      map.addLayer(new whiteTiles());
      map.addLayer(new shadowOverlay());
      edgeOverlays.forEach(e => map.addLayer(new e()));
      map.addLayer(new pointOverlay());
    });
  </script>
</html>
